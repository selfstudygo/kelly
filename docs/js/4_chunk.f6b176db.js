(this.webpackJsonptheblog=this.webpackJsonptheblog||[]).push([[4],{340:function(e,t,n){"use strict";n.d(t,"a",(function(){return c}));var s=n(0),a=n.n(s),r=n(325),i=n.n(r),o=n(341),c=function(e){var t=e.code,n=e.lang||"javascript",s=i.a.highlight(t,i.a.languages[n],n);return a.a.createElement("pre",null,a.a.createElement("code",{spellCheck:"false",dangerouslySetInnerHTML:{__html:s.replace(/^\n/,"")}}),a.a.createElement(o.a,{text:t}))}},354:function(e,t,n){"use strict";n.r(t);var s=n(0),a=n.n(s),r=n(340),i=n(97),o=n(339);t.default=function(e){var t=e.summary;return(a.a.createElement("article",null,a.a.createElement(o.a,{summary:t},a.a.createElement("span",null,"Photo by",a.a.createElement(i.a,{href:"https://unsplash.com/@olav_ahrens",target:"_blank"},"Olav Ahrens R\xf8tne"),"on",a.a.createElement(i.a,{href:"https://unsplash.com/s/photos/computer",target:"_blank"},"Unsplash"))),a.a.createElement("p",null,a.a.createElement("em",null,"RxJS"),"\xa0is a real life savior when it comes to the app with complex data structuring, helps \xa0building solid data pipelines easy and elegant."),a.a.createElement("p",null,"Like any other tools, this conveniency and simplicity comes with the chance of messing up if you don\u2019t know the proper use case, that requires the knowledge of which is the\xa0",a.a.createElement("strong",null,"Better Practice"),"\xa0(still figuring out what is the best)."),a.a.createElement("p",null,"This is from KnowledgeShare at my team and based on some mistakes we\u2019ve seen. Some are silly and some are critical to the app."),a.a.createElement("p",null,"And this is not the official\xa0",a.a.createElement("strong",null,"Better Practice"),", but collected from real cases, it might not apply to your app, but good to know these bad and better cases."),a.a.createElement("p",null,"So Let\u2019s share it."),a.a.createElement("h1",null,"Split logic with operators"),a.a.createElement("p",null,"Simple and Easy first."),a.a.createElement("p",null,"Do not put every operations in the observer\xa0function(next subscriber)."),a.a.createElement("p",null,"Use Operators to lift the burden of them off and make easy to follow the stream and keep function light."),a.a.createElement(r.a,{code:"\n// can be better\nobs$.subscribe((state)=&gt;{\n  if(!state) return;\n  const newState = state.map(...);\n  this.setState(newState);\n});\n\n// is better\nobs$.pipe(\n  filter(Boolean),\n  map((state)=&gt;{...})\n).subscribe((newState)=&gt;{\n  this.setState(newState);\n})\n"}),a.a.createElement("h1",null,"Flatten subscribe function"),a.a.createElement("p",null,"We know callback hell, and it applies to rxjs observer function too."),a.a.createElement("p",null,"Do not use subscribe inside subscribe.\xa0You have plenty of **map and join operators which flatten the stream."),a.a.createElement(r.a,{code:"\n// can be better\nobs$.subscribe((state) => {\n  const obs2$ = ... || ...;\n  obs2$.subscribe((state2) => {\n    const { a } = state;\n    const { b } = state2;\n    this.setValue(a * b);\n  })\n});\n\n// is better\nobs$.pipe(\n  switchMap((state) => {\n    const obs2$ = ... || ...;\n    return obs2$.pipe(\n      map((state2) = &gt; {\n        return state.a * state2.b,\n      })\n    )\n  }),\n).subscribe((multiplied) => {\n  this.setValue(multiplied);\n})\n"}),a.a.createElement("p",null,"Also this practice\xa0can prevent dangerous code like this."),a.a.createElement(r.a,{code:"\ngetTask(taskId).subscribe(({ archive }) => {\n  if ( archive ) { // case *1\n    this.isArchive = true;\n  } else {  // case *2\n    this.getTaskList().subscribe((list) => {\n      this.isArchive = list.length &lt; 1;\n    }) ;\n  }\n});\n"}),a.a.createElement("p",null,"This code is problematic when it is called several times in a row, because second call with case *1 can be faster than the first call with case *2 and past result would override the value of\xa0",a.a.createElement("strong",null,"isArchive"),".\xa0",a.a.createElement("strong",null,"use switchMap Or concatMap Instead"),"."),a.a.createElement("iframe",{title:"flatten",allowFullScreen:!0,src:"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodesandbox.io%2Fembed%2F3qcck&display_name=CodeSandbox&url=https%3A%2F%2Fcodesandbox.io%2Fs%2F3qcck&image=https%3A%2F%2Fcodesandbox.io%2Fapi%2Fv1%2Fsandboxes%2F3qcck%2Fscreenshot.png&key=a19fcc184b9711e1b4764040d3dc5c07&type=text%2Fhtml&schema=codesandbox"}),a.a.createElement("h1",null,"Subscription management"),a.a.createElement("p",null,"It is important to unsubscribe the steam which does not require any more.\xa0If certain observables share lifecycle, good to group it or use takeUntil to unsubscribe the group."),a.a.createElement(r.a,{code:"\n// ** can be better: many variable names harm readability\nconst subscription1 = obs1$.subscribe(...);\nconst subscription2 = obs2$.subscribe(...);\nconst subscription3 = obs3$.subscribe(...);\n\nsubscription1.unsubscribe();\nsubscription2.unsubscribe();\nsubscription3.unsubscribe();\n\n// ** is better to use subscription..\nconst subscriptions = obs1$.subscribe(...);\nsubscriptions.add(obs2$.subscribe(...));\nsubscriptions.add(obs3$.subscribe(...));\n\nsubscriptions.unsubscribe();\n\n// ** is better to use takeUntil\nconst unsbuscribeTrigger$ = new Subject();\nobs1$.pipe(takeUntil(unsbuscribeTrigger$)).subscribe(...);\nobs2$.pipe(takeUntil(unsbuscribeTrigger$)).subscribe(...);\nobs3$.pipe(takeUntil(unsbuscribeTrigger$)).subscribe(...);\n\nunsubscribeTrigger$.next();\nunsubscribeTrigger$.complete();\n"}),a.a.createElement("p",null,"Or add SubscriptionManager"),a.a.createElement(r.a,{code:"\nexport class SubscriptionManager {\n  static G_ID = 1;\n  idx = 0;\n  subscriptions: Record<string, Subscription> = {};\n  instanceId = `SUB_${SubscriptionManager.G_ID++}`;\n\n  destroy(): void {\n    if (!this.subscriptions) {\n      return;\n    }\n    this.unsubscribeAll();\n    this.subscriptions = null;\n  }\n\n  unsubscribeAll(): void {\n    if (!this.subscriptions) {\n      return;\n    }\n    Object.keys(this.subscriptions).forEach((key) => {\n      const sub = this.subscriptions[key];\n      if (!sub.closed) {\n        sub.unsubscribe();\n      }\n    });\n    this.subscriptions = {};\n  }\n\n  unsubscribe(key: string): void {\n    if (this.subscriptions && this.subscriptions[key]) {\n      const sub = this.subscriptions[key];\n      if (!sub.closed) {\n        sub.unsubscribe();\n      }\n      delete this.subscriptions[key];\n    }\n  }\n\n  add(sub: Subscription): string {\n    const key = `${this.instanceId}_${++this.idx}`;\n    this.subscriptions[key] = sub;\n    return key;\n  }\n}\n"}),a.a.createElement("h1",null,"Hot and Cold Observable"),a.a.createElement("p",null,"Hot and Cold Observable are important concepts in RxJS, it has something to do with unicast and multicast."),a.a.createElement("p",null,"Unicast means the source of data is responsible for one observer, on the other hands, multicast takes multiple of them, which means 2 observers(subscribers) require 2 different data stream."),a.a.createElement("p",null,"See the code below and guess how many console.log would be printed."),a.a.createElement(r.a,{code:"\nconst createObservable = (type) => {\n  return new Observable((subscriber) => {\n    let i = 0;\n    const countdown = () => {\n      i++;\n      subscriber.next(i);\n      setTimeout(() => countdown(), 1000);\n    };\n    const start = () => {\n      console.log(`${type} triggered countdown.`);\n      countdown();\n    };\n    start();\n  });\n};\n\n\nconst cold$ = createObservable();\ncold$.subscribe((n) => {\n  console.log(n)\n});\n\ncold$.subscribe((n) => {\n  console.log(n)\n});\n"}),a.a.createElement("p",null,"The answer is 2. cold$ has 2 subscriptions, therefore creates 2 observables."),a.a.createElement("p",null,"Most time it is not expected result. We created one Observable and returned one, then 2 subscriptions make it double?"),a.a.createElement("p",null,"To make the observable above multicast we need add 2 operators."),a.a.createElement(r.a,{code:"\nconst hot$ = createObservable().pipe(publish(), refCount());\n\ncold$.subscribe((n)=&gt;{console.log(n)});\ncold$.subscribe((n)=&gt;{console.log(n)});\n"}),a.a.createElement("p",null,"Now you see 1 console.log"),a.a.createElement("p",null,a.a.createElement("em",null,"publish")," makes your observable multicast(it can be replaced by multicast operator) and ",a.a.createElement("em",null,"refCount")," for managing your subscriptions, when no subscriptions, it will complete the stream. (Another easy option subscribe $cold with Subject\u2014 and subscribe the subject.)"),a.a.createElement("p",null,"Here is the sandbox code for this."),a.a.createElement("iframe",{title:"cold and hot",allowFullScreen:!0,src:"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodesandbox.io%2Fembed%2F1s291&display_name=CodeSandbox&url=https%3A%2F%2Fcodesandbox.io%2Fs%2F1s291&image=https%3A%2F%2Fcodesandbox.io%2Fapi%2Fv1%2Fsandboxes%2F1s291%2Fscreenshot.png&key=a19fcc184b9711e1b4764040d3dc5c07&type=text%2Fhtml&schema=codesandbox"}),a.a.createElement("p",null,"You see, why this is important?"),a.a.createElement("p",null,"At angular, HttpClient.post is cold observable. It rarely happens, but when you put 2 subscriptions to one httpclient.post()?"),a.a.createElement("p",null,"Yes, you sent 2 identical post requests!."),a.a.createElement("p",null,"So these are some better cases that I fixed with my team. There could be better than this better practice and more better practices with other cases.."),a.a.createElement("p",null,"I hope it is helpful to you. :)")))}}}]);